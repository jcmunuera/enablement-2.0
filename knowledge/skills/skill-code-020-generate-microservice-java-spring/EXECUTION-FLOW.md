# Execution Flow: skill-code-020-generate-microservice-java-spring

**Skill Type:** GENERATE  
**Version:** 1.0  
**Last Updated:** 2025-12-05

---

## Overview

This document defines the **deterministic execution flow** for generating a microservice. 
Any AI agent or orchestrator MUST follow these steps exactly to ensure reproducible results.

---

## Prerequisites

Before execution, the following inputs MUST be available:

| Input | Source | Required |
|-------|--------|----------|
| `generation-request.json` | Generated by Discovery phase or user | ✅ |
| `domain-api-spec.yaml` | User provided | ✅ |
| `system-api-spec.yaml` | User provided (if persistence.type=system_api) | Conditional |
| `mapping.json` | User provided or generated | Conditional |

---

## Execution Steps

### Step 1: Validate Input

```
ACTION: Validate generation-request.json against schema
INPUT:  generation-request.json
OUTPUT: Validated input or ERROR

RULES:
1. Load generation-request.json
2. Validate required fields:
   - service.name (string, kebab-case)
   - service.group_id (string, dot notation)
   - service.base_package (string, dot notation)
   - entities[] (at least one)
   - persistence.type (enum: jpa|system_api)
3. If validation fails → STOP with error
4. Log: "Input validated successfully"
```

### Step 2: Resolve Modules

```
ACTION: Determine which modules are required based on features
INPUT:  generation-request.json (features section)
OUTPUT: modules_required[]

RULES:
1. ALWAYS include: mod-015-hexagonal-base-java-spring

2. Check persistence.type:
   - If "jpa" → ADD mod-016-persistence-jpa-spring
   - If "system_api" → ADD mod-017-persistence-systemapi
                     → ADD mod-018-api-integration-rest-java-spring

3. Check features.resilience:
   - If circuit_breaker.enabled=true → ADD mod-001-circuit-breaker-java-resilience4j
   - If retry.enabled=true → ADD mod-002-retry-java-resilience4j
   - If timeout.enabled=true AND timeout.strategy="timelimiter" → ADD mod-003-timeout-java-resilience4j
   - If rate_limiter.enabled=true → ADD mod-004-rate-limiter-java-resilience4j

4. Log: "Modules resolved: [list]"
```

### Step 3: Build Variable Context

```
ACTION: Extract all template variables from input
INPUT:  generation-request.json
OUTPUT: variable_context{}

RULES:
1. Service-level variables:
   - serviceName = service.name (as-is, kebab-case)
   - serviceNamePascal = PascalCase(service.name)
   - serviceNameCamel = camelCase(service.name)
   - groupId = service.group_id
   - artifactId = service.artifact_id OR service.name
   - basePackage = service.base_package
   - basePackagePath = replace(basePackage, ".", "/")
   - javaVersion = technology.java_version OR "17"
   - springBootVersion = technology.spring_boot_version OR "3.2.0"

2. For each entity in entities[]:
   - Entity = entity.name (PascalCase)
   - entityLower = camelCase(entity.name)
   - entityPlural = pluralize(entity.name, lowercase)
   - entityFields = entity.fields[]
   
3. Log: "Variable context built with [count] variables"
```

### Step 4: Process Each Module

```
ACTION: For each resolved module, process its Template Catalog
INPUT:  modules_required[], variable_context{}
OUTPUT: generated_files[]

FOR EACH module IN modules_required:
    
    4.1. Load Template Catalog
         - Read: {module}/MODULE.md
         - Parse: "## Template Catalog" section
         - Extract: list of (template, output_path, condition)
    
    4.2. For Each Template in Catalog
         
         4.2.1. Check Condition
                - If template has condition (e.g., "persistence.type=system_api")
                - Evaluate condition against generation-request.json
                - If FALSE → SKIP this template
         
         4.2.2. Read Template File
                - Path: {module}/templates/{template}
                - If file not found → LOG ERROR, mark as GAP
         
         4.2.3. Render Template
                - Substitute all {{variable}} with values from variable_context
                - Handle loops: {{#entityFields}}...{{/entityFields}}
                - Handle conditionals: {{#if condition}}...{{/if}}
         
         4.2.4. Add Traceability Header
                ```
                // =============================================================================
                // GENERATED CODE - DO NOT EDIT
                // Template: {template_name}
                // Module: {module_id}
                // Generated by: skill-code-020-generate-microservice-java-spring
                // Timestamp: {ISO-8601}
                // =============================================================================
                ```
         
         4.2.5. Write Output File
                - Path: Render output_path with variables
                - Create directories if needed
                - Write content
         
         4.2.6. Record in Manifest
                - Add entry: {output, template, module, variables_used}
    
    4.3. Log: "Module {module} processed: [count] files generated"
```

### Step 5: Merge Configuration Files

```
ACTION: Combine configuration snippets into final files
INPUT:  All generated config files
OUTPUT: Merged application.yml, merged pom.xml

RULES for application.yml:
1. Start with base: mod-015/config/application.yml.tpl output
2. Merge in order (alphabetically by module):
   - mod-001 circuit breaker config (under resilience4j.circuitbreaker)
   - mod-002 retry config (under resilience4j.retry)
   - mod-003 timeout config (under resilience4j.timelimiter)
   - mod-016 JPA config (under spring.datasource, spring.jpa)
   - mod-017 system-api config (under integration.system-api)
   - mod-018 rest-client config (under spring.rest-client)
3. YAML merge strategy: deep merge, later values override

RULES for pom.xml:
1. Start with base: mod-015/config/pom.xml.tpl output
2. Collect all <dependency> blocks from module configs
3. Deduplicate by groupId+artifactId
4. Sort alphabetically by groupId, then artifactId
5. Insert into <dependencies> section

Log: "Configuration files merged"
```

### Step 6: Generate Manifest

```
ACTION: Create traceability manifest
INPUT:  All execution data
OUTPUT: manifest.json

SCHEMA:
{
  "generatedAt": "{ISO-8601 timestamp}",
  "skill": "skill-code-020-generate-microservice-java-spring",
  "skillVersion": "1.2.0",
  "input": {
    "generationRequestHash": "{SHA-256 of generation-request.json}",
    "serviceName": "{service.name}"
  },
  "modulesUsed": [
    {
      "module": "mod-015-hexagonal-base-java-spring",
      "version": "1.1",
      "reason": "always required (base hexagonal)"
    }
  ],
  "filesGenerated": [
    {
      "output": "src/main/java/.../Customer.java",
      "template": "domain/Entity.java.tpl",
      "module": "mod-015-hexagonal-base-java-spring",
      "checksum": "{SHA-256 of generated file}"
    }
  ],
  "improvisations": [],
  "warnings": []
}

WRITE: manifest.json to project root
Log: "Manifest generated with [count] files"
```

### Step 7: Run Validations

```
ACTION: Execute all applicable validators
INPUT:  Generated project
OUTPUT: validation-report.json

7.1. Tier-1 Validation (Universal)
     - Run: validators/tier-1/project-structure-check.sh
     - Run: validators/tier-1/traceability-check.sh
     - Record results

7.2. Tier-2 Validation (Technology)
     - Run: validators/tier-2/java-spring/java-compile-check.sh
     - Run: validators/tier-2/java-spring/spring-boot-check.sh
     - Record results

7.3. Tier-3 Validation (Module-specific)
     FOR EACH module IN modules_used:
         - Run: {module}/validation/*.sh
         - Record results

7.4. Generate Report
     {
       "timestamp": "{ISO-8601}",
       "overall": "PASS|FAIL",
       "tier1": { "status": "PASS", "checks": [...] },
       "tier2": { "status": "PASS", "checks": [...] },
       "tier3": {
         "mod-015": { "status": "PASS", "script": "hexagonal-check.sh", "output": "..." },
         "mod-017": { "status": "PASS", "script": "systemapi-check.sh", "output": "..." }
       }
     }

WRITE: validation-report.json
Log: "Validation complete: {overall_status}"
```

### Step 8: Generate Execution Audit

```
ACTION: Create complete audit trail
INPUT:  All execution data and decisions
OUTPUT: execution-audit.json

SCHEMA:
{
  "executionId": "{UUID}",
  "timestamp": "{ISO-8601}",
  "skill": "skill-code-020-generate-microservice-java-spring",
  "input": {
    "generationRequest": { /* full content */ },
    "additionalInputs": ["domain-api-spec.yaml", "mapping.json"]
  },
  "decisions": {
    "modulesResolved": [
      { "module": "mod-015", "reason": "always required" },
      { "module": "mod-017", "reason": "persistence.type=system_api" }
    ],
    "templatesProcessed": [
      { "template": "Entity.java.tpl", "module": "mod-015", "output": "...", "status": "SUCCESS" }
    ],
    "templatesSkipped": [
      { "template": "JpaEntity.java.tpl", "module": "mod-016", "reason": "persistence.type != jpa" }
    ]
  },
  "improvisations": [
    {
      "description": "No template for X",
      "action": "Created custom implementation",
      "file": "path/to/file",
      "gap": "GAP-XXX - Need template for X"
    }
  ],
  "validation": { /* from validation-report.json */ },
  "outputs": {
    "projectPath": "./customer-domain-api",
    "filesCount": 24,
    "manifestPath": "./customer-domain-api/manifest.json"
  }
}

WRITE: execution-audit.json
Log: "Execution audit generated"
```

---

## Error Handling

| Error | Action |
|-------|--------|
| Input validation fails | STOP, return error with details |
| Template file not found | LOG as GAP, continue if non-critical |
| Template render fails | LOG error, mark file as FAILED in manifest |
| Validation fails (Tier-1/2) | STOP, return validation report |
| Validation fails (Tier-3) | WARN, continue, include in report |

---

## Determinism Guarantees

To ensure reproducible results:

1. **Same input → Same modules:** Module Resolution rules are deterministic
2. **Same modules → Same templates:** Template Catalog is explicit
3. **Same templates → Same output:** Variable substitution is deterministic
4. **Ordering is defined:** Alphabetical processing, explicit merge rules
5. **No external dependencies:** No network calls, no randomness
6. **Full traceability:** Every decision recorded in audit

---

## Outputs Summary

| Output | Path | Purpose |
|--------|------|---------|
| Generated code | `{serviceName}/src/**` | The microservice code |
| `manifest.json` | `{serviceName}/manifest.json` | File-level traceability |
| `validation-report.json` | `{serviceName}/validation-report.json` | Validation results |
| `execution-audit.json` | `./execution-audit.json` | Complete execution trace |
